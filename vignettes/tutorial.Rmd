---
title: "tutorial"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{tutorial}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(hw4)
library(plyr)
```

To use the function `mylm`, use the build in dataset "mtcars" as an example.  
Check all output from `mylm` versus output from `lm`, they give exactly the same estimated values, standard deviation of the estimations, p-values, standard error, degree of freedom, and residuals.

```{r}
mylm(mpg~cyl+disp, data = mtcars)
summary(lm(mpg~cyl+disp, data = mtcars))
```

MORE SPECIFIC WAY TO USE `mylm`:  
Estimated coefficients:  

* use ordinary least square estimation:
```{r}
lm.my <- mylm(mpg~cyl+disp+wt+qsec, data = mtcars)
lm.my$call
lm.my$coefficients
lm(mpg~cyl+disp+wt+qsec, data = mtcars)
```

* deal with sparse regression by doing estimation using coordinate descent.
```{r}
mtcars_modified <- mtcars[1:3,]
mylm(mpg~cyl+disp+wt+qsec, data = mtcars_modified, useSparse = TRUE)
```

* deal with sparse regression and set penalty on larger model
```{r}
mylm(mpg~cyl+disp+wt+qsec, data = mtcars_modified, useSparse = TRUE, penalty = 20)
```

* use specific stopping rules (adjust tolerance) when approximate estimations.
```{r}
mylm(mpg~cyl+disp+wt+qsec, data = mtcars_modified, tol = 1e-10, useSparse = TRUE, useCpp = TRUE)
```

* want faster calculation using rcpp to approximate estimation.
```{r}
mylm(mpg~cyl+disp+wt+qsec, data = mtcars_modified, useSparse = TRUE, useCpp = TRUE)
```



